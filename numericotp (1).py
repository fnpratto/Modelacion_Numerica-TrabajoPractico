# -*- coding: utf-8 -*-
"""NumericoTP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aegS0eFpOK4E1TY_k5fdbX6qLO1V0hfn

## Modelo

Datos proporcionados ajustados con Padron: 110416

* Área de Terreno

\begin{equation}
A_{\text{terr}} = 17.32 \times \left( \frac{NP}{3000} \right) \, \text{m}^2
\end{equation}

\begin{equation}
A_{\text{terr}} = 17.32 \times \left( \frac{110416}{3000} \right) \approx 637.64 \, \text{m}^2
\end{equation}

* Área del Sótano

\begin{equation}
A_{\text{so}} = 8.66 \, \text{m} \times 8.66 \, \text{m} = 75 \, \text{m}^2
\end{equation}

* Caudal máximo de la bomba ($Q_{\text{max}}$): 8 m³/h para la bomba existente
* Desnivel máximo de la bomba ($\Delta H_{\text{max}}$): 4 m
* Desnivel mínimo de la bomba ($\Delta H_{\text{min}}$): 1 m
* Altura del sótano ($H_s$): 3.5 m
* Coeficiente de infiltración con el suelo saturado ($C_{\text{sat}}$): 0.90
* Coeficiente de infiltración inicial ($C_0$): 0.60
* Tiempo Característico

\begin{equation}
t_k = \left( 1 - \frac{NP}{140000} \right) \, \text{h}
\end{equation}

\begin{equation}
t_k = \left( 1 - \frac{110416}{140000} \right) \approx 0.21 \, \text{h}
\end{equation}
"""

import numpy as np
import matplotlib.pyplot as plt
import math

Q_max= 8

# Datos proporcionados ajustados con Padron: 110416
NP = 110416  # Número proporcionado del padron

# Área de Terreno
A_terr = 17.32 * (NP / 3000)  # en metros cuadrados

# Área del Sótano
A_so = 8.66 * 8.66  # en metros cuadrados

# Caudal máximo de la bomba (Q_max)
Q_max = 8  # en metros cúbicos por hora (m^3/h)

# Desnivel máximo de la bomba (Delta_H_max)
Delta_H_max = 4  # en metros

# Desnivel mínimo de la bomba (Delta_H_min)
Delta_H_min = 1  # en metros

# Altura del sótano (H_s)
H_s = 3.5  # en metros

# Coeficiente de infiltración con el suelo saturado (C_sat)
C_sat = 0.90

# Coeficiente de infiltración inicial (C_0)
C_0 = 0.60

# Tiempo Característico
t_k = 1 - NP / 140000  # en horas

#Volumen del sotano
V_so = H_s * A_so


# Datos proporcionados por el enunciado
intensidades = np.array([241.4, 190.7, 162.6, 119.6, 85.0, 41.7, 26.4, 16.7, 10.9, 5.2])  # Intensidades de precipitación en m/h
duraciones = np.array([5, 10, 15, 30, 60, 180, 360, 720, 1440, 4320]) / 60  # Duraciones de precipitación en minutos

# Definición de funciones
#ecuacion 1
def calcular_tasa_cambio_volumen(Q_in, Q_out):
    return Q_in - Q_out

#ecuacion 2
def calcular_caudal_entrada(C, I, A_terr):
    return C * I/1000 * A_terr

## I MM -> M = 0,001 --> digamos dividimos por mil para que quede en metros
# A terr = mcuadrados
# te queda m3/hora

## ecuacion 3:
def calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min):
    argumento = (Delta_H_max - Delta_H) / (Delta_H_max - Delta_H_min)
    if argumento < 0:
        raise ValueError("El argumento de la raíz cuadrada es negativo")

    return Q_max * math.sqrt(argumento)

###

# Qmax = mcubico/hora
# delta m

#ecuacion 4
def calcular_desnivel(H_0, H):
    return H - H_0

#ecuacion 5
def calcular_altura_agua(V, A_so):
    return V / A_so

#ecuacion 6
#def calcular_cambio_coef_infiltracion(V, V_total, V_t, C_sat, C):
#    return (V / (V_total * V_t) * (C_sat - C))

"""## Modelacion del sistema

**A.1 )Discretización de la Ecuación 1 con Método de Euler (C = 1, $Q_{\text{sal}} = 0$)**

Entonces dada la ecuacion 1:

Discrepamos ec 1 usando C=1 y $Q_{sal}$ = 0  el metodo de Euler como :


\Delta V =(Q_{\text{in}} - Q_{\text{out}}).\Delta t
"""

#ecuacion 7
def calcular_cambio_volumen(Q_in, Q_out, delta_t):
    return (Q_in - Q_out) * delta_t

"""Donde $ \Delta V $ es la diferencia del Volumen en $ \Delta t $


Y la ecuacion 6 discretamos como :

\Delta C = \frac{V_{\text{total}}}{V_t \cdot V \cdot} .  (C_{\text{saturado}} - C) \cdot \Delta t

"""

#ecuacion 8
def calcular_cambio_coeficiente_infiltracion(V, C, delta_t ):
    if V < 0 :
        return 0
    cambio_coeficiente = (V / (V_so * t_k)) * (C_sat - C) * delta_t

    return cambio_coeficiente

"""Donde $\Delta C$ es el cambio en el coeficiente de infiltración

Ahora vamos a utilizar la fórmula del método de Euler para actualizar el volumen en cada paso de tiempo hasta que se alcance el tiempo total de la tormenta (60 minutos en este caso)
"""

import matplotlib.pyplot as plt

delta_t = 1/60  # Paso de tiempo en horas, un minuto por iteración
V_t = 0
C = 1
t = 0
I = intensidades[4]
duracion = duraciones[4]
Q_out = 0
Q_in = calcular_caudal_entrada(C, I , A_terr)

tiempos = []
volumenes = []

while t <= duracion:
    tiempos.append(t)
    volumenes.append(V_t)

    delta_V = calcular_cambio_volumen(Q_in, Q_out, delta_t)
    V_t += delta_V
    t += delta_t

# Graficar el volumen del sótano en función del tiempo
plt.plot(tiempos, volumenes, label='Volumen del sótano')
plt.xlabel('Tiempo (horas)')
plt.ylabel('Volumen del agua en sotano (m³)')
plt.title('Simulación de inundación por precipitación')
plt.legend()
plt.grid(True)
plt.show()


# Verificar que el volumen de agua almacenado en el sótano coincida con el volumen de lluvia
print(f"Volumen de agua almacenado en el sótano: {V_t:.2f} m³")
# El area se multiplica por 10 ya que 1mm = 10m3
print(f"Volumen de lluvia para la precipitación de 60 minutos: {(85 * A_terr)/1000 :.2f} m³/hora")

"""Verificamos si el volumen de agua almacenado coincide con el volumen de lluvia.
Es similar pero no igual :(

**A.2) Discretización de las Ecuaciones 1 y 6 con Método de Euler (Variables C y $Q_{\text{sal}}$)}**

Para determinar un lapso suficiente para que se vacíe el sótano, podrías graficar la evolución del volumen de agua en el sótano en función del tiempo. Esto te permitirá visualizar cómo cambia el volumen de agua a lo largo del tiempo y determinar cuándo alcanza un valor cercano a cero.
"""

Q_max = 8

def simular_precipitacion(intensidad, duracion):
    V_t = 0         # Volumen total
    t = 0           # Iterador
    delta_t = 1/60  # Paso de tiempo en horas
    H_0 = 0         # Altura inicial del sótano
    C = C_0         # Coeficiente de infiltración inicial

    tiempos = []
    alturas = []
    Q_outs = []
    Cs = []
    Q_ins = []
    Vs = []

    while t <= duracion:

        H = calcular_altura_agua(V_t, A_so)
        Delta_H = calcular_desnivel(H_0, H)
        Q_out = calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min)
        Q_in = calcular_caudal_entrada(C, intensidad, A_terr)
        delta_V = calcular_cambio_volumen(Q_in, Q_out, delta_t)
        delta_C = calcular_cambio_coeficiente_infiltracion(V_t, C, delta_t)

        C += delta_C
        V_t += delta_V
        if V_t <0:
          V_t = 0
        H_0 = H
        t += delta_t

        tiempos.append(t)
        alturas.append(H)
        Q_outs.append(Q_out)
        Cs.append(C)
        Q_ins.append(Q_in)
        Vs.append(V_t)


    while  t <= (duracion*2):

        if V_t <=0:
          break

        H = calcular_altura_agua(V_t, A_so) #esta en metros
        Delta_H = calcular_desnivel(H_0, H)
        Q_out = calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min)
        Q_in = 0 # dejamos desagotar
        delta_V = calcular_cambio_volumen(Q_in, Q_out, delta_t)
        delta_C = calcular_cambio_coeficiente_infiltracion(V_t, C, delta_t/60 )

        C += delta_C
        V_t += delta_V
        if V_t <0:
          V_t = 0
        t += delta_t
        H_0 = H

        tiempos.append(t)
        alturas.append(H)
        Q_outs.append(Q_out)
        Cs.append(C)
        Q_ins.append(Q_in)
        Vs.append(V_t)

    return tiempos, alturas, Q_outs, Cs, Q_ins, Vs ,V_t, C

# Simular para todas las intensidades y duraciones de precipitación
for i, intensidad in enumerate(intensidades):
    duracion = duraciones[i]
    tiempos, alturas, Q_outs, Cs, Q_ins, Vs, rta_Vt, rta_C = simular_precipitacion(intensidad, duracion)

    print(f"duracion{i}")
    print(f"Intensidad: {intensidad} mm/h, Duración: {duracion*60} min\n")
    print(f"Volumen Resultado: {rta_Vt:.2f} m³\n")
    print(f"Coef de precipitación Resultado: {rta_C}\n")
    print(f"Volumen de lluvia para la duración de la precipitación: {intensidad * A_terr * duracion / 1000:.2f} m³\n")
    print(f"---> Diferencia entre volumen de lluvia y volumen almacenado: {(intensidad * A_terr * duracion / 1000) - rta_Vt:.2f} m³\n")
    print(f"\n")
    plt.figure(figsize=(12, 8))

    plt.subplot(2, 2, 1)
    plt.plot(tiempos, Q_outs, label='Q_out')
    plt.xlabel('Tiempo (horas)')
    plt.ylabel('Q_out (m³/h)')
    plt.title('Caudal de Salida Q_out')
    plt.legend()

    plt.subplot(2, 2, 2)
    plt.plot(tiempos, Cs, label='C')
    plt.xlabel('Tiempo (horas)')
    plt.ylabel('C')
    plt.title('Coeficiente de Infiltración C')
    plt.legend()

    plt.subplot(2, 2, 3)
    plt.plot(tiempos, Q_ins, label='Q_in')
    plt.xlabel('Tiempo (horas)')
    plt.ylabel('Q_in (m³/h)')
    plt.title('Caudal de Entrada Q_in')
    plt.legend()

    plt.subplot(2, 2, 4)
    plt.plot(tiempos, Vs, label='Volumen V_t')
    plt.xlabel('Tiempo (horas)')
    plt.ylabel('Volumen (m³)')
    plt.title('Volumen de Agua V_t')
    plt.legend()

    plt.tight_layout()
    plt.show()

"""**B) Dimensionamiento de la bomba**

Para redimensionar la bomba y garantizar que la altura de agua sobre el piso del sótano no exceda los 0,25 m para ninguna de las precipitaciones de la tabla, podemos utilizar un enfoque iterativo para encontrar el valor adecuado de Qmax

A continuación, presento la implementación para encontrar el nuevo Qmax mediante una simulación iterativa
"""

def altura_agua_excede(intensidad, duracion, Q_max):
    V_t = 0
    t = 0
    delta_t = 5/60
    H_0 = 0
    C= C_0

    tiempos = []
    alturas = []

    while t <= duracion:

        H = calcular_altura_agua(V_t, A_so) #esta en metros
        Delta_H = calcular_desnivel(H_0, H)
        Q_out = calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min)
        delta_C = calcular_cambio_coeficiente_infiltracion(V_t, C, delta_t/60 )
        C += delta_C
        Q_in = calcular_caudal_entrada(C, intensidad, A_terr)
        Delta_V = calcular_cambio_volumen(Q_in, Q_out, delta_t)

        V_t += Delta_V
        if V_t <0:
          V_t = 0
        t += delta_t
        H_0 = H

        tiempos.append(t)
        alturas.append(H)

    while t <= (duracion*2) :

        if V_t <=0:
          break

        H = calcular_altura_agua(V_t, A_so) #esta en metros
        Delta_H = calcular_desnivel(H_0, H)
        Q_out = calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min)
        delta_C = calcular_cambio_coeficiente_infiltracion(V_t, C, delta_t/60 )
        C += delta_C
        Q_in = 0 # dejamos desagotar
        Delta_V = calcular_cambio_volumen(Q_in, Q_out, delta_t)

        V_t += Delta_V
        if V_t <0:
          V_t = 0
        t += delta_t
        H_0 = H

        tiempos.append(t)
        alturas.append(H)


    if H > 0.25:
        return True, tiempos, alturas
    return False, tiempos, alturas

def redimensionar_Q(intensidad, duracion, Q_deseado):
    incremento = 0.1  # Incremento más pequeño para mayor precisión

    vector_Q_deseados = []
    vector_Q_deseados.append(Q_deseado)
    excede = True
    while excede:
        excede, tiempos, alturas = altura_agua_excede(intensidad, duracion, Q_deseado)
        Q_deseado += 0.1
        vector_Q_deseados.extend([Q_deseado] * len(tiempos))

    vector_Q_deseados.extend([Q_deseado] * len(tiempos))
    return Q_deseado, tiempos, alturas, vector_Q_deseados

Q_inicial = 0

# Simular para todas las intensidades y duraciones de precipitación
for i, intensidad in enumerate(intensidades):

    duracion = duraciones[i]
    Q_deseado, tiempos, alturas, vector_Q_deseados = redimensionar_Q(intensidad, duracion, Q_inicial)

    # Graficar los resultados
    plt.figure(figsize=(12, 6))

    plt.subplot(1, 2, 1)
    plt.plot(tiempos, alturas, label='Altura del Sótano')
    plt.axhline(y=0.25, color='r', linestyle='--', label='Altura Máxima Permitida')
    plt.xlabel('Tiempo (horas)')
    plt.ylabel('Altura (m)')
    plt.title('Altura del Sótano')
    plt.legend()


    plt.subplot(1, 2, 2)
    plt.plot(range(len(vector_Q_deseados)), vector_Q_deseados, label='Q_deseado')
    plt.xlabel('Iteracion')
    plt.ylabel('Q_deseado (m³/h)')
    plt.title(' Q_deseado')
    plt.legend()

    plt.tight_layout()
    plt.show()

    print(f"Valor adecuado de Q_max: {Q_deseado}\n")


    max_Q_deseado = max(vector_Q_deseados)
    print(f'La máxima Q_deseado es: {max_Q_deseado} m³/h\n')

"""**C) Experimentación con distintos esquemas**


Implementamos el método de Runge-Kutta de orden 2 y lo comparamos con Euler.


"""

import numpy as np
import matplotlib.pyplot as plt

# Definición de las ecuaciones diferenciales
def dV_dt(Q_in, Q_out):
    return calcular_tasa_cambio_volumen(Q_in, Q_out)

def dC_dt(V, V_sotano, t_k, C_saturado, C):
    return (V / (V_sotano * t_k)) * (C_saturado - C)

# Implementación del método de Runge-Kutta de segundo orden (RK-2)
def runge_kutta_2(Q_in, Q_out, V, V_sotano, t_k, C_saturado, C, dt):
    k1_V = dt * dV_dt(Q_in, Q_out)
    k1_C = dt * dC_dt(V, V_sotano, t_k, C_saturado, C)

    k2_V = dt * dV_dt(Q_in, Q_out + k1_V)
    k2_C = dt * dC_dt(V, V_sotano, t_k, C_saturado, C + k1_C)

    V_new = V + 0.5 * (k1_V + k2_V)
    C_new = C + 0.5 * (k1_C + k2_C)

    return V_new, C_new

# Parámetros de la simulación
delta_t = 1/60  # Paso de tiempo en horas
num_steps = 60  # Número de pasos de tiempo
V_t = 0
t = 0
H_0 = 0
C= C_0

# Simulación usando RK-2
for step in range(num_steps):
    H_rk2 = calcular_altura_agua(V_t, A_so) #esta en metros
    Delta_H = calcular_desnivel(H_0, H_rk2)
    Q_out_rk2 = calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min)
    Q_in = calcular_caudal_entrada(C, 85, A_terr)
    k1_V = delta_t * (Q_in - Q_out_rk2)
    k1_C = delta_t * (V_t / (A_so * t_k) * (C_sat - C))

    k2_V = delta_t * ((Q_in - Q_out_rk2) + k1_V / 2) #Delta_V
    k2_C = delta_t * ((V_t + k1_V / 2) / (A_so * t_k) * (C_sat - (C + k1_C / 2))) ## delta_C

    V_t += k2_V
    C += k2_C

# Resultados finales
print(f"Volumen final usando RK-2: {V_t:.2f} m^3")
print(f"Coeficiente de infiltración final usando RK-2: {C:.2f}")

"""Recordemos numeros dados en el punto A.2 para intensidad 60 minutos"""

def simular_precipitacion(intensidad, duracion):
    Q_max = 8
    V_t = 0         # Volumen total
    t = 0           # Iterador
    delta_t = 1/60  # Paso de tiempo en horas
    H_0 = 0         # Altura inicial del sótano
    C = C_0         # Coeficiente de infiltración inicial

    while t <= duracion :

        H = calcular_altura_agua(V_t, A_so)
        Delta_H = calcular_desnivel(H_0, H)
        Q_out = calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min)
        Q_in = calcular_caudal_entrada(C, intensidad, A_terr)
        delta_V = calcular_cambio_volumen(Q_in, Q_out, delta_t)
        delta_C = calcular_cambio_coeficiente_infiltracion(V_t, C, delta_t)

        V_t += delta_V
        C += delta_C
        t += delta_t
        H_0 = H


    return V_t, C

# Simular para todas las intensidades y duraciones de precipitación
rta_Vt, rta_C = simular_precipitacion(85, 60)
print(f"Volumen Resultado: {rta_Vt:.2f} m³\n")
print(f"Coef de precipitación Resultado: {rta_C}\n")

"""# El método de Runge-Kutta de orden 4 (RK4)"""

def derivadas(V, C, H_0, intensidad):
    H = calcular_altura_agua(V, A_so)
    Delta_H = calcular_desnivel(H_0, H)
    Q_out = calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min)
    Q_in = calcular_caudal_entrada(C, intensidad, A_terr)
    dV = Q_in - Q_out
    dC = calcular_cambio_coeficiente_infiltracion(V, C, 1)
    return dV, dC

def rk4_step(V, C, H_0, intensidad, delta_t):
    dV1, dC1 = derivadas(V, C, H_0, intensidad)
    dV2, dC2 = derivadas(V + 0.5 * delta_t * dV1, C + 0.5 * delta_t * dC1, H_0, intensidad)
    dV3, dC3 = derivadas(V + 0.5 * delta_t * dV2, C + 0.5 * delta_t * dC2, H_0, intensidad)
    dV4, dC4 = derivadas(V + delta_t * dV3, C + delta_t * dC3, H_0, intensidad)

    V_new = V + (delta_t / 6.0) * (dV1 + 2 * dV2 + 2 * dV3 + dV4)
    C_new = C + (delta_t / 6.0) * (dC1 + 2 * dC2 + 2 * dC3 + dC4)

    return V_new, C_new

def simular_precipitacion(intensidad, duracion):
    V_t = 0         # Volumen total
    t = 0           # Iterador
    delta_t = 1/60  # Paso de tiempo en horas
    H_0 = 0         # Altura inicial del sótano
    C = C_0         # Coeficiente de infiltración inicial

    tiempos = []
    alturas = []
    Q_outs = []
    Cs = []
    Q_ins = []
    Vs = []

    # Simulación durante la precipitación
    while t <= duracion:
        V_t, C = rk4_step(V_t, C, H_0, intensidad, delta_t)
        H = calcular_altura_agua(V_t, A_so)
        Delta_H = calcular_desnivel(H_0, H)
        Q_out = calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min)
        Q_in = calcular_caudal_entrada(C, intensidad, A_terr)

        t += delta_t
        H_0 = H

        tiempos.append(t)
        alturas.append(H)
        Q_outs.append(Q_out)
        Cs.append(C)
        Q_ins.append(Q_in)
        Vs.append(V_t)

    # Simulación después de la precipitación (desagote)
    while t <= (duracion*2) :
        V_t, C = rk4_step(V_t, C, H_0, 0, delta_t)  # Intensidad es 0 después de la lluvia
        if V_t < 0:
          break
        H = calcular_altura_agua(V_t, A_so)
        Delta_H = calcular_desnivel(H_0, H)
        Q_out = calcular_caudal_salida(Q_max, Delta_H, Delta_H_max, Delta_H_min)
        Q_in = 0  # Caudal de entrada es cero durante el desagote

        t += delta_t
        H_0 = H

        tiempos.append(t)
        alturas.append(H)
        Q_outs.append(Q_out)
        Cs.append(C)
        Q_ins.append(Q_in)
        Vs.append(V_t)

    return tiempos, alturas, Q_outs, Cs, Q_ins, Vs, V_t, C

for i, intensidad in enumerate(intensidades):
    duracion = duraciones[i]
    tiempos, alturas, Q_outs, Cs, Q_ins, Vs, rta_Vt, rta_C = simular_precipitacion(intensidad, duracion)

    print(f"Duración {i + 1}")
    print(f"Intensidad: {intensidad} mm/h, Duración: {duracion * 60} min\n")
    print(f"Volumen Resultado: {rta_Vt:.2f} m³\n")
    print(f"Coeficiente de infiltración Resultado: {rta_C}\n")
    print(f"Volumen de lluvia para la duración de la precipitación: {intensidad * A_terr * duracion / 1000:.2f} m³\n")
    print(f"---> Diferencia entre volumen de lluvia y volumen almacenado: {(intensidad * A_terr * duracion / 1000) - rta_Vt:.2f} m³\n")
    print(f"\n")

    plt.figure(figsize=(12, 8))

    plt.subplot(2, 2, 1)
    plt.plot(tiempos, Q_outs, label='Q_out')
    plt.xlabel('Tiempo (horas)')
    plt.ylabel('Q_out (m³/h)')
    plt.title('Caudal de Salida Q_out')
    plt.legend()

    plt.subplot(2, 2, 2)
    plt.plot(tiempos, Cs, label='C')
    plt.xlabel('Tiempo (horas)')
    plt.ylabel('C')
    plt.title('Coeficiente de Infiltración C')
    plt.legend()

    plt.subplot(2, 2, 3)
    plt.plot(tiempos, Q_ins, label='Q_in')
    plt.xlabel('Tiempo (horas)')
    plt.ylabel('Q_in (m³/h)')
    plt.title('Caudal de Entrada Q_in')
    plt.legend()

    plt.subplot(2, 2, 4)
    plt.plot(tiempos, Vs, label='Volumen V_t')
    plt.xlabel('Tiempo (horas)')
    plt.ylabel('Volumen (m³)')
    plt.title('Volumen de Agua V_t')
    plt.legend()

    plt.tight_layout()
    plt.show()

"""A continuacion para la conclusion vamos a agregar un grafico con todos los metodos juntos en un solo grafico asi podemos comparar."""